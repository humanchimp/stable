import { describe } from "./describe";
import {
  Suite,
  DslThunk,
  DslDescribeBlock,
  DslDescribeEachBlock,
  DslItBlock,
  DslInfoBlock,
  DslHookBlock,
} from "./interfaces";

export async function dethunk(thunk: DslThunk): Suite {
  let suite: Suite = describe(null);

  // The queue is for capturing each asynchronous step which are dynamically,
  // asynchronously generated by the DSL.
  const queue = [];

  thunk(
    dslDescribe("describe"),
    dslDescribe("xdescribe"),
    dslDescribe("fdescribe"),
    dslDescribeEach("describeEach"),
    dslDescribeEach("xdescribeEach"),
    dslDescribeEach("fdescribeEach"),
    dslIt("it"),
    dslIt("xit"),
    dslIt("fit"),
    dslHook("beforeAll"),
    dslHook("afterAll"),
    dslHook("beforeEach"),
    dslHook("afterEach"),
    dslInfo("info"),
  );

  // We simply wait for each item in the queue to complete. Thanks to the
  // iterator protocol, this code is straightforward and handles the growing
  // and shrinking queue gracefully. :mindblown:
  for (const next of queue) {
    await next();
  }

  // Focus mode propagates across sibling suites!
  suite.isFocusMode = suite.suites.some(suite => suite.isDeeplyFocused);

  return suite;

  function dslDescribe(block: string): DslDescribeBlock {
    return (description, closure) => {
      suite[block](description, s => {
        queue.push(async () => {
          const p = suite;

          suite = s;
          await closure();

          suite = p;
        });
      });
    };
  }

  function dslDescribeEach(block: string): DslDescribeEachBlock {
    return (description, table, closure) => {
      suite[block](description, table, (s, table) => {
        queue.push(async () => {
          const p = suite;

          suite = s;
          await closure(table);

          suite = p;
        });
      });
    };
  }

  function dslIt(block: string): DslItBlock {
    return (description, closure) => {
      suite[block](description, closure);
    };
  }

  function dslHook(block: string): DslHookBlock {
    return closure => {
      suite[block](closure);
    };
  }

  function dslInfo(block: string): DslInfoBlock {
    return (...rest: any[]) => {
      suite[block](...rest);
    };
  }
}
